% Auto-generated snippets for Lewis Convention Theory paper
% Generated from: reasons_improved.lean, Cubitt_Sugden_improved.lean, Sillari_improved.lean

% ======================================================================
% PART 1: JUSTIFICATION LOGIC (reasons_improved.lean)
% ======================================================================

% Core Definitions: R and Ind
% Definition: R
\begin{minted}{lean}
def R {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (i : indiv) (φ : Prop) : Prop :=
  ∃ r, rb r i φ

/--
  Ind φ i ψ: "Individual i's reason for φ indicates ψ"

  In Lewis's terminology, φ "indicates" ψ for i if i has reason to believe
  the conditional "φ → ψ". This captures how evidence for one belief can
  serve as evidence for another.

  Note: This definition makes indication explicit as having a reason for an
  implication, which will allow us to prove properties that were axioms in
  other approaches.
-/
\end{minted}

% Definition: Ind
\begin{minted}{lean}
def Ind {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (φ : Prop) (i : indiv) (ψ : Prop) : Prop :=
  R rb i (φ → ψ)

-- ============================================================================
-- Axioms of Justification Logic
-- ============================================================================

/-
  The following axioms establish a logic of reasons based on Artemov's
  justification logic. These are presented as axioms for now, but in a
  fuller treatment they would be derived from the semantics of justification logic.

  Note: In an ideal formalization, we would define these as parameters of a
  structure rather than global axioms, to make the dependency structure clearer.
-/

/--
  Application Rule (AR): The fundamental rule of justification logic.

  If s is a reason for i to believe "α → β", and t is a reason for i to believe α,
  then s * t (the "application" of s to t) is a reason for i to believe β.

  This is the justification-logic analog of modus ponens, but with explicit
  tracking of which reasons were used in the inference.
-/
\end{minted}

% Justification Logic Axioms
\begin{minted}{lean}
axiom AR {indiv reason : Type} [Mul reason] (rb : reason → indiv → Prop → Prop) :
  ∀ {s t : reason} {i : indiv} {α β : Prop},
  rb s i (α → β) → rb t i α → rb (s * t) i β

/--
  T1: Axiom for conjunction introduction.

  The constant reason 'a' justifies everyone in believing that having α and
  having β together justify believing (α ∧ β).

  This encodes the logical rule: from α and β, infer α ∧ β.
-/
\end{minted}

\begin{minted}{lean}
axiom T1 {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (a : reason) :
  ∀ {i : indiv} {α β : Prop}, rb a i (α → β → (α ∧ β))

/--
  T2: Axiom for transitivity of implication.

  The constant reason 'b' justifies everyone in believing that implications
  are transitive: if α → β and β → γ, then α → γ.

  This encodes the logical rule of hypothetical syllogism.
-/
\end{minted}

\begin{minted}{lean}
axiom T2 {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (b : reason) :
  ∀ {i : indiv} {α β γ : Prop}, rb b i (((α → β) ∧ (β → γ)) → (α → γ))

/--
  T3: Axiom for reasoning about others' reasoning.

  The constant reason 'c' justifies everyone in believing a meta-level principle:
  if j has reason to believe "α → β", and j has reason to believe α,
  then j has reason to believe β.

  This allows agents to reason about other agents' reasoning capabilities.
-/
\end{minted}

\begin{minted}{lean}
axiom T3 {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (c : reason) :
  ∀ {i j : indiv} {α β : Prop},
  rb c i (R rb j (α → β) → (R rb j α → R rb j β))

-- ============================================================================
-- Derived Rules and Lemmas
-- ============================================================================

/--
  E1: Modus ponens for the R operator.

  If i has reason to believe "α → β" and i has reason to believe α,
  then i has reason to believe β.

  This is a direct consequence of the application rule AR, showing how
  the explicit reason structure supports standard logical reasoning.
-/
\end{minted}

\begin{minted}{lean}
axiom T1 (for conjunction) and applies it twice via AR.
-/
\end{minted}

\begin{minted}{lean}
axiom for meta-reasoning).
-/
\end{minted}

% Key Lemmas (E1, E2, E3, A1, A6)
% Lemma: E1
\begin{minted}{lean}
lemma E1 {indiv reason : Type} [Mul reason] (rb : reason → indiv → Prop → Prop) :
    ∀ {i : indiv} {α β : Prop}, R rb i (α → β) → R rb i α → R rb i β := by
  intro i α β h1 h2
  rw [R] at *
  -- Extract the witnesses: s is a reason for α → β, t is a reason for α
  obtain ⟨s, hs⟩ := h1
  obtain ⟨t, ht⟩ := h2
  -- Apply AR: s * t is a reason for β
  use s * t
  exact AR rb hs ht

/--
  L1: Conjunction introduction for R.

  If i has reason to believe α and reason to believe β,
  then i has reason to believe (α ∧ β).

  This uses the axiom T1 (for conjunction) and applies it twice via AR.
-/
\end{minted}

% Lemma: L1
\begin{minted}{lean}
lemma L1 {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (a : reason) :
    ∀ {i : indiv} {α β : Prop}, R rb i α → R rb i β → R rb i (α ∧ β) := by
  intro i α β h1 h2
  rw [R] at *
  obtain ⟨s, hs⟩ := h1
  obtain ⟨t, ht⟩ := h2
  -- First, apply T1 to s to get a reason for "β → (α ∧ β)"
  have h3 : rb (a * s) i (β → (α ∧ β)) := by
    have h4 : rb a i (α → (β → (α ∧ β))) := T1 rb a
    exact AR rb h4 hs
  -- Then apply this to t to get a reason for "α ∧ β"
  use a * s * t
  exact AR rb h3 ht

/--
  E2: Transitivity of implications for R.

  If i has reason to believe "α → β" and reason to believe "β → γ",
  then i has reason to believe "α → γ".

  This uses T2 (transitivity axiom) and builds up the required reason
  by combining existing reasons.
-/
\end{minted}

% Lemma: E2
\begin{minted}{lean}
lemma E2 {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (a b : reason) :
    ∀ {i : indiv} {α β γ : Prop},
    R rb i (α → β) → R rb i (β → γ) → R rb i (α → γ) := by
  intro i α β γ h1 h2
  -- First, form the conjunction of the two implications
  have h3 : R rb i ((α → β) ∧ (β → γ)) := L1 rb a h1 h2
  obtain ⟨s, hs⟩ := h3
  -- Apply T2 to derive the transitive conclusion
  use b * s
  exact AR rb (T2 rb b) hs

/--
  E3: Lifting modus ponens to meta-level reasoning.

  If i has reason to believe "j has reason to believe (α → β)",
  then i has reason to believe "if j has reason to believe α,
  then j has reason to believe β".

  This allows i to reason about j's reasoning capabilities.
  Uses T3 (axiom for meta-reasoning).
-/
\end{minted}

% Lemma: E3
\begin{minted}{lean}
lemma E3 {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (c : reason) :
    ∀ {i j : indiv} {α β : Prop},
    R rb i (R rb j (α → β)) → R rb i (R rb j α → R rb j β) := by
  intro i j α β h1
  obtain ⟨s, hs⟩ := h1
  use c * s
  exact AR rb (T3 rb c) hs

-- ============================================================================
-- Lewis's Axioms A1 and A6 as Theorems
-- ============================================================================

/-
  CRITICAL RESULT: Unlike Sillari's formalization where A1 and A6 were axioms
  (and A1 was shown to be inconsistent with the modal semantics), here we
  PROVE them from the more primitive justification logic axioms.

  This shows that the justification logic approach provides a more solid
  foundation for Lewis's theory.
-/

/--
  A1 (Lewis's first key axiom): Indication supports reasoning.

  If i's reason for A indicates α (i.e., i has reason to believe "A → α"),
  and i has reason to believe A, then i has reason to believe α.

  PROOF: This is simply an instance of modus ponens (E1), since Ind A i α
  is defined as R rb i (A → α).

  In Cubitt and Sugden's approach, this was taken as an axiom.
  In Sillari's modal approach, this was shown to FAIL (counterexample exists).
  Here, it's a trivial consequence of the definitions.
-/
\end{minted}

% Lemma: A1
\begin{minted}{lean}
lemma A1 {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (A : Prop) :
    ∀ {i : indiv} {α : Prop}, Ind rb A i α → R rb i A → R rb i α := by
  intro i α h1 h2
  rw [Ind] at h1
  rw [R] at *
  obtain ⟨t, ht⟩ := h2
  obtain ⟨s, hs⟩ := h1
  -- s * t is the reason combining the implication with the antecedent
  use s * t
  exact AR rb hs ht

/-- Alternative proof of A1 using E1 directly (more concise) -/
\end{minted}

% Lemma: A1_alternative_proof
\begin{minted}{lean}
lemma A1_alternative_proof {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (A : Prop) :
    ∀ {i : indiv} {α : Prop}, Ind rb A i α → R rb i A → R rb i α :=
  fun h1 h2 => E1 rb h1 h2

/--
  A6 (Lewis's composition axiom): Chaining indication through reasoning.

  If i's reason for A indicates "j has reason to believe A"
  (i.e., Ind A i (R j A)), and i has reason to believe "j's reason for A indicates α"
  (i.e., R i (Ind A j α)), then i's reason for A indicates "j has reason to believe α"
  (i.e., Ind A i (R j α)).

  This captures how indication composes through multiple agents' reasoning.

  PROOF: Uses E2 (transitivity) and E3 (meta-level reasoning) to chain
  the implications appropriately.

  In Cubitt and Sugden's approach, this was taken as an axiom.
  Here, it follows from the more primitive principles of justification logic.
-/
\end{minted}

% G Inductive Definition (from reasons_improved.lean)
\begin{minted}{lean}
inductive G {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (φ : Prop) : Prop → Prop
  | base : G rb φ φ  -- φ is in its own closure
  | step (p : Prop) (i : indiv) : G rb φ p → G rb φ (R rb i p)
    -- If p is in the closure, so is "i has reason to believe p"

/--
  Lewis's Main Theorem: Common knowledge via R-closure

  Given the four conditions that Lewis identifies as constituting common knowledge:
  - C1: Everyone has reason to believe A (the common basis)
  - C2: Everyone indicates that everyone has reason to believe A
  - C3: Everyone indicates φ (the initial observation)
  - C4: If i indicates α, then i reasons that everyone indicates α

  Then: For any proposition p in the R-closure of φ, everyone has reason to believe p.

  This formalizes Lewis's key insight: under the right conditions, an initial
  observation φ becomes "common reason to believe" (everyone believes it, everyone
  believes everyone believes it, ad infinitum).

  PROOF STRATEGY:
  - By induction on the R-closure structure
  - Base case: C3 gives us that everyone indicates φ, then C1 and A1 give that everyone believes φ
  - Inductive case: Use C4 to lift indication, then A6 to compose indication, then A1 to conclude

  This proof is non-trivial and genuinely demonstrates how common knowledge arises
  from Lewis's four conditions, unlike the trivial proof in the global interpretation
  of Sillari's formalization.
-/
\end{minted}

% Lewis's Main Theorem
\begin{minted}{lean}
lemma Lewis {indiv reason : Type} [Mul reason]
    (rb : reason → indiv → Prop → Prop) (A φ : Prop) (a b c : reason) (p : Prop)
    (C1 : ∀ i, R rb i A)  -- Everyone has reason to believe the common basis
    (C2 : ∀ i j, Ind rb A i (R rb j A))  -- Everyone indicates everyone believes A
    (C3 : ∀ i, Ind rb A i φ)  -- Everyone indicates the initial observation
    (C4 : ∀ α i j, Ind rb A i α → R rb i (Ind rb A j α))  -- Indication propagates
    (h7 : G rb φ p) :  -- p is in the R-closure of φ
    ∀ i, R rb i p := by  -- Conclusion: everyone has reason to believe p
  intro i
  -- Key insight: we prove the stronger claim that Ind A i p, then apply A1
  have h1 : Ind rb A i p := by
    induction h7 with
    | base =>
        -- Base case: p = φ, so Ind A i φ holds by C3
        exact C3 _
    | step u j hu ih =>
        -- Inductive case: p = R j u, and we have ih: Ind A i u
        -- Goal: Ind A i (R j u)

        -- Step 1: From ih and C4, get R i (Ind A j u)
        have h3 : R rb i (Ind rb A j u) := C4 u _ _ ih

        -- Step 2: Apply A6 with C2 to get Ind A i (R j u)
        have h4 : R rb i (Ind rb A j u) → Ind rb A i (R rb j u) :=
          A6 rb A a b c u (C2 _ _)
        have h5 : Ind rb A i (R rb j u) := h4 h3
        exact h5
  -- Apply A1: from Ind A i p and C1, conclude R i p
  exact A1 rb A h1 (C1 _)

-- Verify the statement is well-formed and can be used
\end{minted}

% ======================================================================
% PART 2: R-CLOSURE EXTENDED (Cubitt_Sugden_improved.lean)
% ======================================================================

% R-Closure Inductive Definition
\begin{minted}{lean}
inductive RC (R : indiv → Prop → Prop) (φ : Prop) : Prop → Prop
| base : RC R φ φ  -- φ is in its own R-closure
| step {u : Prop} (j : indiv) (hu : RC R φ u) : RC R φ (R j u)
  -- If u is in the closure, so is R j u for any individual j
\end{minted}

% Main R-Closure Lemmas
% ind_of_rc
\begin{minted}{lean}
lemma ind_of_rc
  (A6 : ∀ {i j : indiv} {u : Prop}, Ind A i (R j A) ∧ R i (Ind A j u) → Ind A i (R j u))
  (C2 : ∀ i j : indiv, Ind A i (R j A))
  (C3 : ∀ i : indiv, Ind A i φ)
  (C4 : ∀ {i j : indiv} {u : Prop}, Ind A i u → R i (Ind A j u))
  {i : indiv} {q : Prop} (h : RC R φ q) : Ind A i q := by
  induction h with
  | base => exact C3 i  -- Base case: i indicates φ by C3
  | @step v j _ ih =>
      -- Inductive case: if i indicates v, show i indicates R j v
      have h₁ : R i (Ind A j v) := C4 ih  -- By C4, i reasons to "j indicates v"
      have h₂ : Ind A i (R j v) := A6 ⟨C2 i j, h₁⟩  -- By A6 composition
      exact h₂

/--
  Main theorem: If p is in the R-closure of φ, then every individual reasons to p.
  This establishes that propositions in the R-closure achieve common reasoning.
-/
\end{minted}

% everyone_reason_of_rc
\begin{minted}{lean}
lemma everyone_reason_of_rc
  (A1 : ∀ {i : indiv} {p : Prop}, Ind A i p → R i A → R i p)
  (A6 : ∀ {i j : indiv} {u : Prop}, Ind A i (R j A) ∧ R i (Ind A j u) → Ind A i (R j u))
  (C1 : ∀ i : indiv, R i A)
  (C2 : ∀ i j : indiv, Ind A i (R j A))
  (C3 : ∀ i : indiv, Ind A i φ)
  (C4 : ∀ {i j : indiv} {u : Prop}, Ind A i u → R i (Ind A j u))
  (hp : RC R φ p) : ∀ i : indiv, R i p := by
  intro i
  have hInd : Ind A i p := ind_of_rc A6 C2 C3 C4 hp  -- i indicates p
  exact A1 hInd (C1 i)  -- Since i indicates p and reasons to A, i reasons to p

-- Concrete examples showing specific elements in the R-closure

/-- R j φ is in the R-closure: everyone reasons to it -/
\end{minted}

% Concrete Examples (Nested Reasoning)
% L1
\begin{minted}{lean}
lemma L1
  (A1 : ∀ {i : indiv} {p : Prop}, Ind A i p → R i A → R i p)
  (A6 : ∀ {i j : indiv} {u : Prop}, Ind A i (R j A) ∧ R i (Ind A j u) → Ind A i (R j u))
  (C1 : ∀ i : indiv, R i A)
  (C2 : ∀ i j : indiv, Ind A i (R j A))
  (C3 : ∀ i : indiv, Ind A i φ)
  (C4 : ∀ {i j : indiv} {u : Prop}, Ind A i u → R i (Ind A j u))
  (i j : indiv) : R i (R j φ) := by
  have h₁ : Ind A i φ := C3 i  -- i indicates φ
  have h₂ : R i (Ind A j φ) := C4 h₁  -- i reasons to "j indicates φ"
  have h₃ : Ind A i (R j φ) := A6 ⟨C2 i j, h₂⟩  -- i indicates "j reasons to φ"
  exact A1 h₃ (C1 i)  -- Therefore i reasons to "j reasons to φ"

/-- R j (R k φ) is in the R-closure: depth-2 nesting -/
\end{minted}

% L2
\begin{minted}{lean}
lemma L2
  (A1 : ∀ {i : indiv} {p : Prop}, Ind A i p → R i A → R i p)
  (A6 : ∀ {i j : indiv} {u : Prop}, Ind A i (R j A) ∧ R i (Ind A j u) → Ind A i (R j u))
  (C1 : ∀ i : indiv, R i A)
  (C2 : ∀ i j : indiv, Ind A i (R j A))
  (C3 : ∀ i : indiv, Ind A i φ)
  (C4 : ∀ {i j : indiv} {u : Prop}, Ind A i u → R i (Ind A j u))
  (i j k : indiv) : R i (R j (R k φ)) := by
  have h₁ : Ind A i φ := C3 i
  have h₂ : R i (Ind A k φ) := C4 h₁
  have h₃ : Ind A i (R k φ) := A6 ⟨C2 i k, h₂⟩
  have h₄ : R i (Ind A j (R k φ)) := C4 h₃
  have h₅ : Ind A i (R j (R k φ)) := A6 ⟨C2 i j, h₄⟩
  exact A1 h₅ (C1 i)

/-- R j (R k (R ℓ φ)) is in the R-closure: depth-3 nesting -/
\end{minted}

% L3
\begin{minted}{lean}
lemma L3
  (A1 : ∀ {i : indiv} {p : Prop}, Ind A i p → R i A → R i p)
  (A6 : ∀ {i j : indiv} {u : Prop}, Ind A i (R j A) ∧ R i (Ind A j u) → Ind A i (R j u))
  (C1 : ∀ i : indiv, R i A)
  (C2 : ∀ i j : indiv, Ind A i (R j A))
  (C3 : ∀ i : indiv, Ind A i φ)
  (C4 : ∀ {i j : indiv} {u : Prop}, Ind A i u → R i (Ind A j u))
  (i j k ℓ : indiv) : R i (R j (R k (R ℓ φ))) := by
  have h₁ : Ind A i φ := C3 i
  have h₂ : R i (Ind A ℓ φ) := C4 h₁
  have h₃ : Ind A i (R ℓ φ) := A6 ⟨C2 i ℓ, h₂⟩
  have h₄ : R i (Ind A k (R ℓ φ)) := C4 h₃
  have h₅ : Ind A i (R k (R ℓ φ)) := A6 ⟨C2 i k, h₄⟩
  have h₆ : R i (Ind A j (R k (R ℓ φ))) := C4 h₅
  have h₇ : Ind A i (R j (R k (R ℓ φ))) := A6 ⟨C2 i j, h₆⟩
  exact A1 h₇ (C1 i)
\end{minted}

% ======================================================================
% PART 3: SILLARI'S KRIPKE SEMANTICS (Sillari_improved.lean)
% ======================================================================

% Multi-Agent Kripke Frame
\begin{minted}{lean}
structure MultiAgentFrame (Agent : Type) where
  /-- The type of possible worlds -/
  World : Type
  /-- Accessibility relation for each agent: rel i w v means agent i considers v accessible from w -/
  rel : Agent → World → World → Prop
\end{minted}

% Kripke Semantics Definitions
% R
\begin{minted}{lean}
def R (i : Agent) (φ : frame.World → Prop) : frame.World → Prop :=
    fun w => ∀ v, frame.rel i w v → φ v

/--
  Rg φ w: All agents have reason to believe φ at world w.
  This is the "group" or "everyone" version of R.
-/
\end{minted}

% Ind
\begin{minted}{lean}
def Ind (i : Agent) (φ : frame.World → Prop) (ψ : frame.World → Prop) : frame.World → Prop :=
  fun w => R i φ w ∧ (φ w → ψ w)

-- ============================================================================
-- Common Reason to Believe (CRB) via Reachability
-- ============================================================================

/--
  connected w1 w2: There exists some agent i who relates w1 to w2.
  This is the union of all agents' accessibility relations.
-/
\end{minted}

% Rg
\begin{minted}{lean}
def Rg (φ : frame.World → Prop) : frame.World → Prop :=
    fun w => ∀ i, R i φ w

/--
  Ind i φ ψ w: Agent i's belief in φ "indicates" ψ at world w.
  This captures Lewis's second central concept: "indication".
  It means: (1) i has reason to believe φ, and (2) φ materially implies ψ at w.
-/
\end{minted}

% CRB
\begin{minted}{lean}
def CRB (ψ : frame.World → Prop) (s : frame.World) : Prop :=
  ∀ w, trcl (connected : frame.World → frame.World → Prop) s w → ψ w

/-- If you can reach a world where ψ fails, then CRB ψ does not hold. -/
\end{minted}

% connected
\begin{minted}{lean}
def connected (w1 w2 : frame.World) : Prop :=
  ∃ i : Agent, frame.rel i w1 w2

/--
  trcl r: Transitive closure of a binary relation r.
  trcl r x z holds if there's a path from x to z following r one or more times.
-/
\end{minted}

% Transitive Closure and CRB
\begin{minted}{lean}
inductive trcl (r : frame.World → frame.World → Prop) : frame.World → frame.World → Prop
| base {x y} : r x y → trcl r x y  -- Single step: x → y
| step {x y z} : r x y → trcl r y z → trcl r x z  -- Multi-step: x → y → ... → z

/-- Convenience lemma: prepend a step to an existing path -/
\end{minted}

% ======================================================================
% PROVABLE AXIOMS (B1, B2, B4, B5, B6, B10, B11)
% ======================================================================

% Axiom B1
\begin{minted}{lean}
lemma B1 : ∀ w, R i φ w → R i (φ ⟶ₘ ψ) w → R i ψ w := by
  intros v h1 h2 u h3
  -- At world u (accessible from v): φ u and (φ → ψ) u both hold, so ψ u holds
  rw [R] at *
  have h4 : φ u := h1 u h3
  have h5 : (φ ⟶ₘ ψ) u := h2 u h3
  exact h5 h4

/-- B2: If i reasons to φ and φ implies ψ at w, then i's reason for φ indicates ψ -/
\end{minted}

% Axiom B2
\begin{minted}{lean}
lemma B2 : ∀ w, R i φ w → (φ ⟶ₘ ψ) w → Ind i φ ψ w := by
  intro w h1 h2
  -- Ind requires: i has reason to believe φ, and φ → ψ at w
  constructor
  { assumption }
  { intro h3
    exact h2 h3 }

/--
  B3 FAILS: The claim "R i φ w ∧ Ind i φ ψ w → R i ψ w" does not hold.

  This is Sillari's version of Lewis's axiom A1, which is crucial for Lewis's argument.
  The failure shows a fundamental problem with Sillari's formalization.

  Counterexample: A two-world frame where i relates s to t but not s to itself.
  Let φ = "world ≠ s" and ψ = "world ≠ t".
  Then R i φ s and Ind i φ ψ s both hold, but R i ψ s fails (since ψ t is false).
-/
\end{minted}

% Axiom B4
\begin{minted}{lean}
lemma B4 : ∀ w, Ind i φ γ w → Ind i γ ψ w → Ind i φ ψ w := by
  intro w h1 h2
  constructor
  { exact h1.1 }  -- R i φ w holds from first premise
  { -- Chain the implications: φ → γ → ψ
    have h4 : φ w → γ w := h1.2
    have h5 : γ w → ψ w := h2.2
    intro hw
    exact h5 (h4 hw) }

/-- B5: Modus ponens for valid formulas -/
\end{minted}

% Axiom B5
\begin{minted}{lean}
lemma B5 : (⊢ φ) → (⊢ (φ ⟶ₘ ψ)) → (⊢ ψ) := by
  intro h1 h2 w
  exact h2 w (h1 w)

/-- B6: Necessitation rule - valid formulas are believed by everyone everywhere -/
\end{minted}

% Axiom B6
\begin{minted}{lean}
lemma B6 : (⊢ φ) → (⊢ R i φ) := by
  intro h1 u
  rw [R]
  intro v _
  exact h1 v

/-
  B7 and B8 (positive and negative introspection) are not provable from the semantics alone.
  They would require the accessibility relations to be transitive (B7) and serial (B8).
  Sillari states these axioms but does not use them in his main argument.
-/

/-- B10: If ψ is CRB at s, then everyone at s reasons to "ψ and CRB ψ" -/
\end{minted}

% Axiom B10
\begin{minted}{lean}
lemma B10 : ⊢ CRB φ ⟶ₘ Rg (φ ∧ₘ CRB φ) := by
  intro s hCR i t hst
  -- Show: ∀ i t, frame.rel i s t → (φ ∧ₘ CRB φ) t
  constructor
  · -- φ holds at t because it's reachable from s in one step
    exact hCR t (trcl.base ⟨i, hst⟩)
  · -- CRB φ holds at t: any world reachable from t was reachable from s
    intro w htw
    exact hCR w (trcl.step ⟨i, hst⟩ htw)

/-- B11: If φ always indicates "everyone believes (ψ ∧ φ)", then φ implies CRB ψ -/
\end{minted}

% Axiom B11
\begin{minted}{lean}
lemma B11 : (⊢ φ ⟶ₘ Rg (ψ ∧ₘ φ)) → ⊢ (φ ⟶ₘ CRB ψ) := by
  intro hvalid s hφs
  -- Show: at any world s where φ holds, CRB ψ also holds
  -- Key insight: (ψ ∧ φ) propagates along any reachable path from s
  have propagate :
      ∀ {x y}, φ x →
        trcl (connected : frame.World → frame.World → Prop) x y →
        (ψ y ∧ φ y) := by
    intro x y hφx hxy
    induction hxy with
    | base hconn =>
        -- One-step case: use the hypothesis that φ x implies Rg (ψ ∧ φ) x
        rename_i x y
        rcases hconn with ⟨j, hj⟩
        have hRg : Rg (ψ ∧ₘ φ) x := (hvalid x) hφx
        exact hRg j y hj
    | step hconn hrest ih =>
        -- Multi-step case: apply one step then use induction
        rename_i x y z
        rcases hconn with ⟨j, hj⟩
        have hRg : Rg (ψ ∧ₘ φ) x := (hvalid x) hφx
        have hy : (ψ ∧ₘ φ) y := hRg j y hj
        -- Continue from y using φ y
        exact ih hy.2
  -- Conclude: ψ holds at any world reachable from s
  intro w hsw
  exact (propagate hφs hsw).1

-- ============================================================================
-- Cubitt and Sugden's Axiom C4 Also Fails
-- ============================================================================

/--
  C4 FAILS: The claim "Ind i φ ψ w → R i (Ind j φ ψ) w" does not hold.

  This is Cubitt and Sugden's axiom, which should hold if Sillari's formalization
  correctly captures Lewis's account of common knowledge. The failure is more
  evidence that Sillari's approach is problematic.

  Counterexample: Two-world frame, φ = True, ψ = "world = s".
  Agent i relates s to t. Then Ind i φ ψ s holds, but R i (Ind j φ ψ) s fails
  because at world t, Ind j φ ψ is false (since ψ t is false).
-/
\end{minted}

% ======================================================================
% COUNTEREXAMPLES: FAILURES OF SILLARI'S FORMALIZATION
% These are the main results showing Sillari's approach fails
% ======================================================================

% B3_fails
\begin{minted}{lean}
lemma B3_fails
  (h1 : two_worlds s t)  -- s and t are distinct
  (h2a : ¬ frame.rel i s s)  -- i doesn't relate s to itself
  (h2b : frame.rel i s t) :  -- i relates s to t
    ¬ (∀ w (φ ψ : frame.World → Prop), R i φ w → Ind i φ ψ w → R i ψ w) := by
  let ψ := fun w => w ≠ t  -- ψ says "not at world t"
  let φ := fun w => w ≠ s  -- φ says "not at world s"
  push_neg
  -- R i φ s holds: the only successor of s is t, and φ t (i.e., t ≠ s) is true
  have h4 : R i φ s := by rw [R]; aesop
  -- Ind i φ ψ s holds: R i φ s ∧ (φ s → ψ s), and both conjuncts are true
  have h5 : Ind i φ ψ s := by rw [Ind]; aesop
  -- But R i ψ s fails: at successor t, we have ¬ψ t (i.e., ¬(t ≠ t))
  have h6 : ¬ R i ψ s := by
    intro hR
    exact (hR t h2b) rfl
  -- Package the counterexample
  refine ⟨s, φ, ψ, ?_, ?_, ?_⟩
  · exact h4
  · exact h5
  · exact h6

/-- B4: Transitivity of indication -/
\end{minted}

% C4_fails
\begin{minted}{lean}
lemma C4_fails
  (h2a : ¬ frame.rel i s s)  -- i doesn't relate s to itself
  (h2b : frame.rel i s t) :  -- i relates s to t
    ¬ ∀ w (φ ψ : frame.World → Prop), (Ind i φ ψ w → R i (Ind j φ ψ) w) := by
  let φ := fun _ : frame.World => True  -- φ is always true
  let ψ := fun w : frame.World => w = s  -- ψ says "at world s"
  push_neg
  -- Ind i φ ψ s holds trivially
  have h3 : Ind i φ ψ s := by
    constructor
    { intro w _; aesop }
    { aesop }
  -- But R i (Ind j φ ψ) s fails: at world t, we have ¬(Ind j φ ψ t)
  have h3a : ¬ R i (Ind j φ ψ) s := by
    rw [R]
    push_neg
    use t
    constructor
    { exact h2b }
    { intro hn
      -- At t, ψ t is false but φ t is true, contradicting the implication in Ind
      have hphi : φ t := by aesop
      have hp : ψ t := hn.2 hphi
      have h3b : ¬ ψ t := by aesop
      aesop }
  use s, φ, ψ

-- ============================================================================
-- Lewis's Theorem: Two Interpretations, Both Problematic
-- ============================================================================

/-
  Sillari attempts to prove Lewis's main theorem about conventions and common knowledge.
  However, it's unclear how to interpret his proof. We examine two possible readings:

  Option 1: Assumptions C1-C3 hold only at the specific world s where we want the conclusion.
           Problem: The theorem is FALSE (we give counterexamples).

  Option 2: Assumptions C1-C3 hold at ALL worlds.
           Problem: The proof becomes TRIVIAL and the theorem is vacuous/useless.
-/
\end{minted}

% Lewis_fails_1i
\begin{minted}{lean}
lemma Lewis_fails_1i
    (h3w : three_worlds s u v)  -- s, u, v are three distinct worlds
    (hrel :
      frame.rel =
        (fun (_ : Agent) (w1 w2 : frame.World) =>
          (w1 = s ∧ w2 = u) ∨ (w1 = u ∧ w2 = v)))  -- Linear: s → u → v
     : ∃ (φ : frame.World → Prop),
      R i1 φ s ∧
      Ind i1 (R i1 φ) (R i1 (R i1 φ)) s ∧
      Ind i1 (R i1 φ) (R i1 (fun w => w = u)) s ∧
      ¬ CRB (fun w => w = u) s := by
  -- Unpack: s, u, v are pairwise distinct
  obtain ⟨hsu, hvu, hvs⟩ : u ≠ s ∧ v ≠ u ∧ v ≠ s := by
    simpa [three_worlds] using h3w

  -- Define the propositions
  let φ : frame.World → Prop := fun w => w ≠ s  -- "not at s"
  let ψ : frame.World → Prop := fun w => w = u  -- "at u"

  -- Extract the frame structure
  have rel_s_u : frame.rel i1 s u := by
    have : (s = s ∧ u = u) ∨ (s = u ∧ u = v) := Or.inl ⟨rfl, rfl⟩
    simp [hrel]
  have rel_u_v : frame.rel i1 u v := by
    have : (u = s ∧ v = u) ∨ (u = u ∧ v = v) := Or.inr ⟨rfl, rfl⟩
    simp [hrel]

  -- Helper: only successor of s is u
  have succ_s_eq_u :
      ∀ w, frame.rel i1 s w → w = u := by
    intro w hw
    have hw' : (s = s ∧ w = u) ∨ (s = u ∧ w = v) := by
      simpa [hrel] using hw
    cases hw' with
    | inl h => exact h.2
    | inr h => exact (hsu.symm h.1).elim

  -- Helper: only successor of u is v
  have succ_u_eq_v :
      ∀ x, frame.rel i1 u x → x = v := by
    intro x hx
    have hx' : (u = s ∧ x = u) ∨ (u = u ∧ x = v) := by
      simpa [hrel] using hx
    cases hx' with
    | inl h => exact (hsu h.1).elim
    | inr h => exact h.2

  -- (1) R i1 φ s: agent i1 has reason to believe φ at s
  have hRphi_s : R i1 φ s := by
    intro w hw
    have : w = u := succ_s_eq_u w hw
    simpa [φ, this] using hsu

  -- (2) R i1 (R i1 φ) s: agent i1 has reason to believe "i1 has reason to believe φ"
  have hR_Rphi_s : R i1 (R i1 φ) s := by
    intro w hw
    intro x hx
    have hw_u : w = u := succ_s_eq_u w hw
    have hx_v : x = v := by
      subst hw_u
      exact succ_u_eq_v x hx
    simpa [φ, hx_v] using hvs

  -- (3) The first Ind condition holds at s
  have hInd1 : Ind i1 (R i1 φ) (R i1 (R i1 φ)) s := by
    exact ⟨hR_Rphi_s, fun _ => hR_Rphi_s⟩

  -- (4) R i1 ψ s: agent i1 has reason to believe ψ at s
  have hRpsi_s : R i1 ψ s := by
    intro w hw
    have : w = u := succ_s_eq_u w hw
    simp [ψ, this]

  -- (5) The second Ind condition holds at s
  have hInd2 : Ind i1 (R i1 φ) (R i1 ψ) s := by
    exact ⟨hR_Rphi_s, fun _ => hRpsi_s⟩

  -- (6) But CRB fails: there's a 2-step path s → u → v, and ψ v is false
  have hNotCR : ¬ CRB (fun w => w = u) s := by
    intro hCR
    -- Build path: s → u → v
    have hsv : trcl connected s v :=
      trcl.head ⟨i1, rel_s_u⟩ (trcl.base ⟨i1, rel_u_v⟩)
    -- CRB would force v = u, contradicting hvu
    have : v = u := hCR v hsv
    exact hvu this

  -- Package all the witnesses
  exact ⟨φ, hRphi_s, hInd1, hInd2, hNotCR⟩

/--
  Counterexample 2: Two agents, three worlds (with transitive, serial relations if desired).

  This shows the failure persists even with nicer frame properties (for those
  who accept axioms B7/B8 requiring transitivity and seriality).
-/
\end{minted}

% Lewis_fails_2i
\begin{minted}{lean}
lemma Lewis_fails_2i
  (h1 : three_worlds s u v)  -- Three distinct worlds
  (h2 : two_agents i1 i2)  -- Two distinct agents
  (h3 : frame.rel = fun i w1 w2 =>
    (i = i1 ∧ w1 = s ∧ w2 = u) ∨
    (i = i1 ∧ w1 = u ∧ w2 = u) ∨  -- i1's relation is transitive at u
    (w1 = v ∧ w2 = v) ∨  -- Reflexive at v for all agents
    (i = i2 ∧ w1 = s ∧ w2 = s) ∨  -- i2 reflexive at s
    (i = i2 ∧ w1 = u ∧ w2 = v))  -- i2 connects u to v
  : ¬ ∀ i φ ψ, Rg φ s → Ind i (Rg φ) (Rg (Rg φ)) s → Ind i (Rg φ) (Rg ψ) s → CRB ψ s := by
  rw [two_agents] at h2
  rw [three_worlds] at h1

  let φ : frame.World → Prop := fun _ => True  -- φ is always true
  let ψ : frame.World → Prop := fun w => w ≠ v  -- ψ says "not at v"
  push_neg
  use i1, φ, ψ

  -- Rg φ s: everyone has reason to believe φ at s (trivial since φ = True)
  have h41 : Rg φ s := by
    intro i w
    have h4a : i = i1 ∨ i = i2 := h2.right i
    cases h4a with
    | inl i1 => aesop
    | inr i2 => aesop

  -- Rg (Rg φ) s: everyone has reason to believe "everyone has reason to believe φ"
  have h42a : Rg (Rg φ) s := by
    rw [Rg]
    intro i x
    rw [Rg]
    intro _ w hw
    aesop

  -- First Ind condition
  have h42 : Ind i1 (Rg φ) (Rg (Rg φ)) s := by
    rw [Ind]
    constructor
    { exact h42a i1 }
    { intro _; exact h42a }

  -- Second Ind condition (Rg ψ holds at s)
  have h43 : Ind i1 (Rg φ) (Rg ψ) s := by
    constructor
    { exact h42a i1 }
    { intro hphi
      rw [Rg]
      intro i
      rw [R]
      intro w
      aesop }

  -- But CRB ψ s fails: v is reachable via s → u → v, and ψ v is false
  have h44 : ¬ CRB ψ s := by
    rw [CRB]
    push_neg
    use v
    simp-- Build the path s → u → v using both agents
    have h5a : connected s u := by use i1; aesop
    have h5b : connected u v := by use i2; aesop
    exact trcl.head h5a (trcl.base h5b)

  aesop
\end{minted}

% lewis_s_2
\begin{minted}{lean}
lemma lewis_s_2
  (C1 : ∀ w, Rg φ w)  -- Everyone believes φ at every world
  (C3 : ∀ w, Ind i (Rg φ) (Rg ψ) w) :  -- At every world, Rg φ indicates Rg ψ
    CRB ψ s := by
  -- From C3: at any world w, since Rg φ w holds (by C1), we get Rg ψ w
  have hRgψ_all : ∀ w, Rg ψ w := fun w => (C3 w).2 (C1 w)
  -- Now show CRB ψ s: ψ holds at all worlds reachable from s
  intro v hv
  induction hv with
  | base h_edge =>
      -- Base case: v is one step from some world x
      rename_i x y
      rcases h_edge with ⟨j, hj⟩
      -- Since Rg ψ x holds, and j relates x to y, we have ψ y
      exact (hRgψ_all x) j y hj
  | step _ _ ih =>
      -- Inductive case: just use the induction hypothesis
      exact ih
\end{minted}

